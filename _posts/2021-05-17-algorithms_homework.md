---

title:  "알고리즘 기초 정리"

search: true
categories: 
  - Algorithms
---



# 알고리즘

# 분할정복의 원리 및 특징

분할 정복 방법이란 이름에서 알 수 있듯이 문제를 해결 하는 방법으로 분할(divide)과 정복(conquer)          의 방법을 사용한다.

문제를 해결하는 단계는 분할 -> 정복 -> 합병 순으로 진행 한다.

분할은 어떠한 문제를 해결할 때 문제를 작은 문제로 쪼개는 것을 의미하고 정복은 그 문제가 더 이상 쪼개지지 않으면 해결하는 것을 의미한다. 그 해결한 문제를 다른 해결한 문제와 합치는 것을 합병이라고 한다. 합병을 하면 쪼개지지 전 원래의 문제를 해결할 수 있다.


# 동적 프로그래밍 원리 및 특징

분할정복과 유사하게 문제를 분할해서 해결하지만 분할된 문제를 저장하느냐 안 하느냐의 차이점이 있다.

동적 프로그래밍은 분할해서 해결한 문제의 값을 저장한다. 그리하여 재계산할 필요 없게 한다. 전체 문제의 최적해를 구하는 방법으로 많이 사용하는데 주로 최솟값이나 최대값을 구할 때 사용한다.

# 욕심쟁이 방법 원리 및 특징

동적프로그래밍 방법에서 고안 되었으며 각 문제의 최적해를 구하다 보면 전체의 최적해를 구해진다의 모토로 사용하는 방법이다. 이렇듯 욕심쟁이 방법은 각 단계의 최적해를 우선적으로 한다. 그러다 보니 전체적인 최적해를 구하지 못하는 경우가 있다. 이러한 이유로 실질적으로는 문제를 해결하는 경우가 많이 없다고 한다. 주로 근사치 예측으로 사용한다고 한다.

# 분할정복의 알고리즘들

분할 정복 방법으로 사용하고 있는 방법들은 여러가지가 있다.

이진탐색, 합병정렬, 퀵정렬, 선택문제 등이 있는데 여기서는 이진 탐색과 합병정렬만 다루도록 하겠다.

이진탐색: 중간 값의 높고 낮음을 기준으로 배열에서 특정한 값을 찾아내는 방법이다 특정한 값을 X라고 한다면 중간 값보다 낮을 시 중간 값의 좌측 배열에서 특정한 값을 탐색, 반대로 X가 중간 값보다 높을 시에는 중간 값 기준 배열 우측에서 탐색한다. 분할정복 특성상 작아 질 수 없을 때 까지 문제가 분할 되는데 이진 탐색도 마찬가지로 중간값 기준으로 좌우측 중 한곳으로 이동 탐색후 이동한 배열 기준으로 다시 중간값을 구한 후 재탐색을 한다. 이 방법을 값을 찾을 때까지 반복 후 분할 했던 배열들을 전부 합병 한다. 이진탐색의 필수 조건은 배열이 정렬된 배열이여야 한다. 시간 복잡도는 이다.

합병정렬: 분할 정복의 방법 중 하나로 더 이상 분할 될 수 없을 때까지 재귀적으로 분할한 후 정렬 -> 합병 -> 정렬 -> 합병 -> 정렬을 반복적으로 수행하여 전체 배열을 정렬하는 방법이다. 시간 복잡도는 이다.

# 동적프로그래밍의 알고리즘들

동적프로그래밍의 문제로 대표적인 것은 최단 경로 구하는 방법으로 사용하는 플로이드 알고리즘이 있다. 모든 정점에서 다른 모든 정점으로의 최단 경로를 구하는 방법으로 사용한다. 예를 들어 정점에서 까지 가는 경로에서 경유점 를 경유하는 길과 경유하지 않는 길을 비교하여 최저 값을 구한다. 여기서 중요한 것은 경로의 길어 즉 가중치의 합이 음수가 되어서는 안된다. 경유없이 지나는 경우, k를 경유하여 지나는 경우 중 가장 가중치가 적은 경우 이렇게 두 경우를 비교한다. 간선이 없는 경로의 경우 무한대의 값으로 대체하여 가중치를 구한다. 수식화 하면   로 나타낼 수 있다. 시간 복잡도는 이다.

# 욕심쟁이 알고리즘들

대표적으로는 데이크스트라(또는 다익스트라) 알고리즘이 있다. 최단경로를 구하는 방법으로 한 정점에서 다른 모든 정점의 최단 경로를 구하는 방법으로 사용한다. 위에서 언급한 모든 정점에서 다른 모든 정점으로의 최단 경로 구하는 알고리즘인 플로이드 알고리즘과는 차이가 있다. 시간 복잡도는 으로 최단경로를 구할 수 있다. 사전 조건이 필요한데 간선 중 음수가 없어야 한다. 원리는 욕심쟁이 방법의 특징인 각 단계의 최적해를 구하는 방법으로 점진적으로 해를 구한다. 시간 복잡도는 정점의 개수 만큼 for loop을 하고 loop 안에서는 각 정점의 인접한 다른 개수만큼 for loop을 실행한다. For loop 을 두 번 사용하기에 시간 복잡도가 이다.
